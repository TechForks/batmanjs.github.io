#!/usr/bin/env coffee

_      = require('underscore')
fs     = require('fs')
glob   = require('glob')
hljs   = require('highlight.js')
yaml   = require('js-yaml')
marked = require('marked')

argv   = require('optimist')
           .usage('Usage: $0 -dir [docs directory]')
           .demand('dir')
           .argv

NamespaceParser = require('./namespace_parser')
batmanVersion = new NamespaceParser("#{argv.dir}/src/namespace.coffee").toString()
console.log "--- GENERATING DOCS FOR BATMAN.JS v#{batmanVersion} ---"

IdGenerator = require('./id_generator')
Autolink = require('./autolink')
TemplateWriter = require('./template_writer')

class DocGenerator
  constructor: ->
    @tokens = []
    @allIds = []

  registerId: (id) ->
    @allIds.push(id)
  hasId: (id) ->
    id in @allIds

  addContent: (contentString) ->
    @tokens = @tokens.concat(marked.lexer(contentString))

  render: ->
    sections = []
    @tokens.forEach (token) =>
      if token.type == 'heading' && token.depth == 1
        sections.push(new DocSection(title: token.text, sub: [], tokens: [], index: sections.length, generator: @))

      else if token.type == 'heading' && token.depth == 2
        section = _.last(sections)
        section.sub.push(new DocSection(title: token.text, tokens: [], index: section.sub.length, generator: @))

      else
        section = _.last(sections)
        sub     = _.last(section.sub)

        if sub?
          sub.tokens.push(token)
        else
          section.tokens.push(token)

    sections.forEach (section, index) -> section.render()

    index = sections.map (section) ->
      subIndex = section.sub.map (sub) -> id: sub.id, title: sub.title
      id: section.id, title: section.title, sub: subIndex, meta: section.meta

    groupings = {}
    for entry in index
      groupingName = entry.meta?.grouping ? "Ungrouped"
      parentName = entry.meta?.parent
      if parentName
        parentEntry = _.findWhere(groupings[groupingName], {title: parentName})
        parentEntry.children ?= []
        parentEntry.children.push(entry)
      else
        groupings[groupingName] ?= []
        groupings[groupingName].push(entry)

    TemplateWriter.write('config.yml', '_config.yml', api_index: yaml.dump(api_index: groupings))


class DocSection
  constructor: ({@title, @tokens, @sub, @index, @generator}) ->
    @options  = highlight: (code, lang) -> hljs.highlight('coffeescript', code).value
    if @title.substr(0, 5) is '/api/'
      {@title, @meta} = HeadingParser.parse(@title)
    # manually handle the index page
    @id = if @index == 0
      "index"
    else
      @generateId(@title)
    @generator.registerId(@id) # to make sure we're linking real pages

  parseSubs: ->
    usedIds = {}
    @sub?.forEach (sub, subIndex) =>
      {title, meta} = HeadingParser.parse(sub.title)

      if meta
        id = @generateId("#{meta.level}_#{meta.type}_#{title}")
        sub.meta = meta
      else
        id = @generateId(title)

      sub.id = id
      offset = 0
      while usedIds[sub.id]
        offset++
        sub.id = "#{id}_#{offset}"

      usedIds[sub.id] = true

      sub.title = title
      sub.html = @_parseTokens(sub.tokens, @options)

  toObject: ->
    obj = {@title}
    obj.meta = @meta if @meta?
    obj.sub = (s.toObject() for s in @sub) if @sub?.length?
    obj.tokens = @tokens
    obj.id = @id if @id?
    obj.html = @html
    obj

  render: ->
    @html = @_parseTokens(@tokens, @options)
    @parseSubs()
    TemplateWriter.write('api.html', "docs/api/v#{batmanVersion}/#{@id}.html", api_doc: yaml.dump(@toObject()))
    TemplateWriter.write('api.html', "docs/api/#{@id}.html", api_doc: yaml.dump(@toObject()))

  generateId: (title) -> new IdGenerator(title).toString()

  _parseTokens: (tokens, options) ->
    tokens.forEach (t) =>
      if t.type in ["paragraph", "listitem"]
        t.text = Autolink.insertLinks(t.text, @generator)

    tokens.links = {}
    options = _.extend({}, marked.defaults, options)
    marked.Parser.parse(tokens, options)

class HeadingParser
  @parse: (title) ->
    # Expects `/api/Data Structures/Batman.Set/SetIndex`
    # or `::%length` etc
    if title.match(/\/api\//)
      @_parseFileHeading(title)
    else
      @_parseSectionHeading(title)

  @_parseFileHeading: (title) ->
    titleSegments = title.split("/")
    fileTitle = titleSegments.pop()
    titleSegments.splice(0,2) # trash '', 'api'
    meta = {grouping: titleSegments[0], parent: titleSegments[1]}
    {title: fileTitle, meta}

  @_parseSectionHeading: (title) ->
    if title.match(/^@/)
      level = "class"
      title = title.match(/^@(.*)/)[1]
    else if title.match(/^::/)
      level = "prototype"
      title = title.match(/^::(.*)/)[1]
    else return { title }

    type = 'property' if title[0] is '.'
    type = 'accessor' if title[0] is '%'
    title = title.substr(1) if type
    type ||= 'function'

    res = title.match(/(.+?)([[( :].*)/)
    if res
      [match, title, meta] = res
      [match, params, returnType] = meta.match(/(?:\((.*)\))?\s*:?\s*(.*)/)
      unless params?
        [match, params, returnType] = meta.match(/(\[.*\])?\s*:?\s*(.*)/)

      returnType = undefined unless returnType

    {title, meta: {type, level, params, returnType}}

docFiles = glob.sync("#{argv.dir}/docs/**/*.litcoffee")
docGenerator = new DocGenerator
for f in docFiles
  fileContent = fs.readFileSync(f).toString()
  docGenerator.addContent(fileContent)

docGenerator.render()
